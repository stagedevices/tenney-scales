import { promises as fs } from "node:fs";
import path from "node:path";
import { approximateCents } from "./approx.js";
import { parseKbm, generateMinimalKbm } from "./kbm.js";
import { listPackSlugs, loadPack, validatePackDates, validateSlugMatchesFolder } from "./pack.js";
import { parseScala } from "./scala.js";
import {
  foldToOctave,
  ratioToMonzoWithOctave,
  reduce,
  compareRatios,
  toCents
} from "./ratio.js";
import {
  formatCents,
  packsDir,
  uuidV5,
  writeJsonFile,
  writeTextFile,
  normalizeISO8601NoMillis
} from "./utils.js";
import type { RatioRef, ScaleBuilderPayload } from "./types.js";

const UUID_NAMESPACE = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";

export async function normalizePacks(): Promise<void> {
  const slugs = await listPackSlugs();
  for (const slug of slugs) {
    const pack = await loadPack(slug);
    validateSlugMatchesFolder(pack, slug);
    validatePackDates(pack);
    await normalizePack(slug);
  }
}

async function normalizePack(slug: string): Promise<void> {
  const pack = await loadPack(slug);
  const packRoot = path.join(packsDir, slug);
  const scalaPath = path.join(packRoot, pack.inputs.scala);
  const scalaRaw = await fs.readFile(scalaPath, "utf8");
  const scala = parseScala(scalaRaw);
  const title = pack.title || scala.description;
  const comments = scala.comments.filter((comment) => comment.length > 0);
  const notes = [pack.description, ...comments].filter(Boolean).join("\n");

  const kbmPath = pack.inputs.kbm ? path.join(packRoot, pack.inputs.kbm) : null;
  const kbmRaw = kbmPath ? await fs.readFile(kbmPath, "utf8") : null;
  const kbm = kbmRaw ? parseKbm(kbmRaw) : null;

  const primeLimit = pack.defaults.primeLimit;
  const degrees = scala.degrees.map((degree) => {
    if (degree.type === "ratio") {
      return reduce(degree.p, degree.q);
    }
    return approximateCents(degree.cents, primeLimit).ratio;
  });

  const periodRatio = reduce(2, 1);
  const filtered = degrees.filter((ratio, index) => {
    const source = scala.degrees[index];
    if (source.type === "cents" && Math.abs(source.cents - 1200) < 1e-6) {
      return false;
    }
    if (source.type === "ratio" && source.p === 2 && source.q === 1) {
      return false;
    }
    if (source.type === "ratio" && source.p === 1 && source.q === 1) {
      return false;
    }
    return !compareRatios(ratio, periodRatio) && !compareRatios(ratio, reduce(1, 1));
  });

  const refs: RatioRef[] = [];
  const seen = new Set<string>();
  for (const ratio of filtered) {
    const folded = foldToOctave(ratio);
    const monzo = ratioToMonzoWithOctave(folded.p, folded.q, folded.octave);
    const key = `${folded.p}/${folded.q}@${folded.octave}`;
    if (seen.has(key)) {
      continue;
    }
    seen.add(key);
    refs.push({
      p: folded.p,
      q: folded.q,
      octave: folded.octave,
      monzo
    });
  }

  const rootHz = kbm ? kbm.referenceFrequency : pack.defaults.rootHz;

  const payload: ScaleBuilderPayload = {
    id: uuidV5(`${pack.slug}:${title}`, UUID_NAMESPACE),
    source: "library",
    title,
    notes,
    rootHz,
    primeLimit,
    refs,
    axisShift: {},
    autoplayAll: false,
    startInLibrary: true,
    existing: null,
    stagingBaseCount: null,
    createdAt: normalizeISO8601NoMillis(pack.createdAt ?? ""),
    updatedAt: normalizeISO8601NoMillis(pack.updatedAt ?? "")
  };

  const tenneyDir = path.join(packRoot, "tenney");
  await writeJsonFile(path.join(tenneyDir, "scale-builder.json"), payload);

  const scl = buildScalaExport(scala.description, refs);
  await writeTextFile(path.join(tenneyDir, "export.scl"), scl);
  const ascl = buildScalaExport(scala.description, refs);
  await writeTextFile(path.join(tenneyDir, "export.ascl"), ascl);

  if (kbmRaw) {
    await writeTextFile(path.join(tenneyDir, "export.kbm"), kbmRaw.endsWith("\n") ? kbmRaw : `${kbmRaw}\n`);
  } else {
    const kbmExport = generateMinimalKbm(rootHz, refs.length + 1);
    await writeTextFile(path.join(tenneyDir, "export.kbm"), kbmExport);
  }
}

function buildScalaExport(description: string, refs: RatioRef[]): string {
  const lines: string[] = [];
  lines.push("! Generated by tenney-normalize");
  lines.push(description);
  lines.push(`${refs.length + 2}`);
  lines.push("1/1");
  for (const ref of refs) {
    if (ref.octave === 0 && isSmallRatio(ref.p, ref.q)) {
      lines.push(`${ref.p}/${ref.q}`);
    } else {
      const cents = toCents({ n: ref.p * Math.pow(2, ref.octave), d: ref.q });
      lines.push(formatCents(cents));
    }
  }
  lines.push("2/1");
  return lines.join("\n") + "\n";
}

function isSmallRatio(p: number, q: number): boolean {
  return p <= 64 && q <= 64;
}
